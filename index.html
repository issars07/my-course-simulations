<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M/M/S Queueing Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 24px;
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }
        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }
        .section-title {
            color: #1e3a8a;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 16px;
        }
        .input-group label {
            font-weight: 600;
            color: #475569;
            margin-bottom: 4px;
            display: block; 
            /* Fixed height to accommodate two lines of text, ensuring inputs align */
            height: 48px; 
            box-sizing: border-box;
            overflow: hidden; /* Hide overflow if text slightly exceeds height */
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            background-color: #f8fafc;
            color: #334155;
        }
        button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        button:hover {
            transform: translateY(-1px);
        }
        #startButton {
            background-color: #22c55e;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.3), 0 2px 4px -1px rgba(34, 197, 94, 0.08);
        }
        #startButton:hover {
            background-color: #16a34a;
        }
        #stopButton {
            background-color: #ef4444;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.3), 0 2px 4px -1px rgba(239, 68, 68, 0.08);
        }
        #stopButton:hover {
            background-color: #dc2626;
        }
        #resetButton {
            background-color: #64748b;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(100, 116, 139, 0.3), 0 2px 4px -1px rgba(100, 116, 139, 0.08);
        }
        #resetButton:hover {
            background-color: #475569;
        }
        .metric-box {
            background-color: #e0f2fe;
            border: 1px solid #90cdf4;
            border-radius: 8px;
            padding: 12px 16px;
        }
        .metric-label {
            font-weight: 600;
            color: #1e40af;
        }
        .metric-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1c52b2;
        }
        #simulationCanvas {
            background-color: #e2e8f0;
            border: 1px solid #94a3b8;
            border-radius: 8px;
            width: 100%;
            height: 450px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            overflow: hidden;
        }

        /* Visualization specific styles */
        .system-border {
            fill: none;
            stroke: #64748b;
            stroke-width: 4px;
            stroke-dasharray: 5 5;
            border-radius: 10px;
        }
        .door {
            fill: #94a3b8;
            stroke: #475569;
            stroke-width: 2px;
            border-radius: 5px;
        }
        .server-item {
            fill: #fcd34d;
            stroke: #d97706;
            stroke-width: 2px;
            rx: 10px; ry: 10px;
        }
        .server-text {
            font-size: 18px;
            text-anchor: middle;
            fill: #333;
            font-weight: bold;
        }
        .queue-line {
            stroke: #94a3b8;
            stroke-width: 2px;
        }
        .queue-text {
            font-size: 18px;
            text-anchor: middle;
            fill: #333;
            font-weight: bold;
        }
        .customer-circle {
            fill: #60a5fa;
            stroke: #2563eb;
            stroke-width: 1px;
            r: 20;
        }
        .customer-text {
            font-size: 14px;
            text-anchor: middle;
            fill: white;
            pointer-events: none;
        }
        .customer-in-service {
            fill: #f97316;
            stroke: #ea580c;
        }

        /* Animations for customer flow */
        .customer-entering-path, .customer-moving-to-server, .customer-leaving-path {
            animation-fill-mode: forwards; /* Keep the end state of the animation */
        }

        @keyframes enterPath {
            from {
                transform: translate(0, 0);
                opacity: 0;
            }
            to {
                transform: translate(
                    calc(var(--target-x) - var(--initial-x)),
                    calc(var(--target-y) - var(--initial-y))
                );
                opacity: 1;
            }
        }
        @keyframes moveToService {
            from { transform: translate(0, 0); }
            to { transform: translate(var(--target-x), var(--target-y)); }
        }
        @keyframes leavePath {
            from { transform: translate(0, 0); opacity: 1; }
            to { transform: translate(var(--target-x), var(--target-y)); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Control Panel -->
        <div class="control-panel p-4">
            <h2 class="section-title">Simulation Controls</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div class="input-group">
                    <label for="arrivalRate">Average Arrival Rate (λ, customers/min):</label>
                    <input type="number" id="arrivalRate" value="24" min="0.1" step="0.1" class="rounded-lg">
                </div>
                <div class="input-group">
                    <label for="serviceRate">Average Service Rate (μ, customers/min/server):</label>
                    <input type="number" id="serviceRate" value="30" min="0.1" step="0.1" class="rounded-lg">
                </div>
                <div class="input-group">
                    <label for="numServers">Number of Servers (S):</label>
                    <input type="number" id="numServers" value="1" min="1" step="1" class="rounded-lg">
                </div>
                <div class="input-group">
                    <label for="simSpeed">Simulation Speed (ms per sim-second):</label>
                    <input type="number" id="simSpeed" value="10" min="10" step="10" class="rounded-lg">
                </div>
                <div class="input-group flex items-center col-span-1 md:col-span-2 mt-2">
                    <input type="checkbox" id="noMaxCustomers" class="mr-2 rounded" checked>
                    <label for="noMaxCustomers" class="font-semibold text-gray-700 mb-0">No Maximum Customers (Run Indefinitely)</label>
                </div>
                <div class="input-group" id="maxCustomersContainer" style="display: none;">
                    <label for="maxCustomers">Max Customers to Serve:</label>
                    <input type="number" id="maxCustomers" value="50" min="1" step="1" class="rounded-lg">
                </div>
            </div>

            <div class="input-group mb-6">
                <p class="font-semibold text-gray-700 mb-2">Distribution Types (M/M/S uses Exponential):</p>
                <div class="flex flex-wrap gap-4">
                    <div class="flex items-center">
                        <input type="radio" id="distExp" name="distribution" value="exponential" checked class="mr-2">
                        <label for="distExp">Exponential (M/M/S)</label>
                    </div>
                    <div class="flex items-center">
                        <input type="radio" id="distFixed" name="distribution" value="fixed" class="mr-2">
                        <label for="distFixed">Fixed</label>
                    </div>
                </div>
                <p class="text-sm text-gray-500 mt-2">
                    For M/M/S, both inter-arrival and service times are exponentially distributed.
                    Other distributions are for demonstration purposes and deviate from a strict M/M/S.
                </p>
            </div>

            <div class="flex flex-col sm:flex-row gap-4">
                <button id="startButton" class="flex-1">START SIMULATION</button>
                <button id="stopButton" class="flex-1" disabled>STOP SIMULATION</button>
                <button id="resetButton" class="flex-1">RESET</button>
            </div>
        </div>

        <!-- Metrics Display -->
        <div class="metrics-display p-4">
            <h2 class="section-title">Real-time Metrics</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div class="metric-box">
                    <div class="metric-label">Current Time (min):</div>
                    <div id="currentTime" class="metric-value">0.00</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Customers in System:</div>
                    <div id="customersInSystem" class="metric-value">0</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Customers in Queue:</div>
                    <div id="customersInQueue" class="metric-value">0</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Customers Being Served:</div>
                    <div id="customersInService" class="metric-value">0</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Avg. Wait Time in Queue (Wq, min):</div>
                    <div id="avgWaitTime" class="metric-value">0.00</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Avg. Time in System (Ws, min):</div>
                    <div id="avgTimeInSystem" class="metric-value">0.00</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Avg. Customers in Queue (Lq):</div>
                    <div id="avgCustomersInQueueDisplay" class="metric-value">0.00</div>
                </div>
                 <div class="metric-box">
                    <div class="metric-label">Avg. Customers in System (Ls):</div>
                    <div id="avgCustomersInSystemDisplay" class="metric-value">0.00</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Actual System Utilization:</div>
                    <div id="systemUtilization" class="metric-value">0.00%</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Customers Served:</div>
                    <div id="customersServed" class="metric-value">0</div>
                </div>
            </div>
            <div class="mt-6 p-3 bg-blue-100 text-blue-800 rounded-lg text-sm" id="statusMessage">
                Adjust parameters and click START.
            </div>
        </div>

        <!-- Simulation Visualization -->
        <div class="col-span-1 md:col-span-2 p-4">
            <h2 class="section-title">Simulation Visualization</h2>
            <svg id="simulationCanvas" viewBox="0 0 800 450" preserveAspectRatio="xMidYMid meet">
                <!-- System Border -->
                <rect x="50" y="50" width="700" height="350" class="system-border"></rect>
                <text x="400" y="75" font-size="20" text-anchor="middle" fill="#333">Queueing System Boundary</text>

                <!-- Entry Door -->
                <rect x="40" y="200" width="10" height="50" class="door"></rect>
                <text x="30" y="225" font-size="16" text-anchor="end" alignment-baseline="middle" fill="#333">Entry</text>

                <!-- Exit Door -->
                <rect x="750" y="200" width="10" height="50" class="door"></rect>
                <text x="770" y="225" font-size="16" text-anchor="start" alignment-baseline="middle" fill="#333">Exit</text>

                <!-- Queue Line -->
                <line x1="130" y1="295" x2="590" y2="295" class="queue-line"></line>
                <text x="360" y="320" font-size="20" text-anchor="middle" fill="#333">Waiting Line (Queue)</text>

                <!-- Servers will be dynamically drawn here -->
                <g id="serversGroup"></g>
                <text x="700" y="100" font-size="20" text-anchor="middle" fill="#333">Servers</text>
            </svg>
        </div>
    </div>

    <script>
        // Utility Functions for Random Distributions
        class Distribution {
            /**
             * Generates a random time from an exponential distribution.
             * @param {number} rate - The average rate (e.g., customers/minute).
             * @returns {number} The generated time. Returns 0 if rate is non-positive.
             */
            static exponential(rate) {
                if (rate <= 0) return 0;
                return -Math.log(Math.random()) / rate;
            }

            /**
             * Generates a fixed time, essentially 1 divided by the rate.
             * Used for deterministic processes (not standard M/M/S).
             * @param {number} value - The rate at which events occur (e.g., customers/minute).
             * @returns {number} The fixed time interval.
             */
            static fixed(value) {
                return 1 / value;
            }

            /**
             * Generates next inter-arrival or service time based on chosen distribution type.
             * Rates are per minute, returns time in minutes.
             * @param {number} rate - The rate for the distribution.
             * @param {string} type - The distribution type ('exponential' or 'fixed').
             * @returns {number} The generated time.
             */
            static generateTime(rate, type) {
                if (type === 'exponential') {
                    return Distribution.exponential(rate);
                } else if (type === 'fixed') {
                    return Distribution.fixed(rate);
                }
                return 0; // Default or error case
            }
        }

        // Customer Class to hold data and reference to SVG elements
        class Customer {
            /**
             * @param {number} id - Unique identifier for the customer.
             * @param {number} arrivalTime - The simulation time when the customer arrived at the system.
             */
            constructor(id, arrivalTime) {
                this.id = id;
                this.arrivalTime = arrivalTime;
                this.queueEntryTime = null;
                this.serviceStartTime = null;
                this.serviceEndTime = null;
                this.leaveTime = null;
                this.element = null; // Reference to the SVG circle element
                this.textElement = null; // Reference to the SVG text element
                this.isVisualized = false; // Flag to track if customer is currently visually on canvas
                allCustomerObjects.set(id, this); // Add customer to global map
            }
        }

        // Global Simulation State and Parameters
        let simulationInterval = null; // Holds the setInterval ID for pausing/stopping
        let currentTime = 0; // Current simulation time in minutes
        let customerCounter = 0; // Counts total customers created
        let eventQueue = []; // Prioritized list of future events, sorted by time: [{time, type, customer, serverId}, ...]

        let customersInQueue = []; // Array of Customer objects currently waiting in line
        let servers = []; // Array of server objects: {busy: boolean, customer: Customer, busyStartTime: number}
        let completedCustomers = []; // Array of Customer objects that have left the system

        let allCustomerObjects = new Map(); // Maps customer ID to Customer object for global tracking

        // Metrics for time-weighted averages
        let totalSystemBusyTime = 0; // Sum of time all servers have been busy
        let totalCustomersInQueueArea = 0; // Area under Lq(t) curve for average queue length
        let totalCustomersInSystemArea = 0; // Area under L(t) curve for average system occupancy
        let lastMetricUpdateTime = 0; // The last time metrics were updated for accumulation calculations

        // Input Parameters (rates are per minute) - Default values
        let avgArrivalRatePerMin = 24; // λ (lambda) - Default changed to 24
        let avgServiceRatePerMinPerServer = 30; // μ (mu)
        let numServers = 1; // S
        let simSpeedMsPerSec = 10; // Milliseconds per simulation second (visual speed) - Default changed to 10
        let maxCustomersToServe = 50; // Maximum customers to serve before stopping (if not infinite)
        let noMaxCustomers = true; // Boolean, true for infinite run
        let distributionType = 'exponential'; // 'exponential' or 'fixed'

        // DOM Elements - Declared globally, assigned on window.onload
        let arrivalRateInput;
        let serviceRateInput;
        let numServersInput;
        let simSpeedInput;
        let maxCustomersInput;
        let noMaxCustomersCheckbox;
        let maxCustomersContainer;
        let distExpRadio;
        let distFixedRadio;

        let startButton;
        let stopButton;
        let resetButton;

        let currentTimeDisplay;
        let customersInSystemDisplay;
        let customersInQueueDisplay;
        let customersInServiceDisplay;
        let avgWaitTimeDisplay;
        let avgTimeInSystemDisplay;
        let avgCustomersInQueueDisplay;
        let avgCustomersInSystemDisplay;
        let systemUtilizationDisplay;
        let customersServedDisplay;
        let statusMessageDisplay;

        let simulationCanvas; // The SVG element
        let serversGroup; // The <g> element for servers
        const SVG_NS = "http://www.w3.org/2000/svg"; // SVG Namespace constant

        // Fixed Layout Constants (pixels in SVG viewBox)
        const SYSTEM_BORDER_X = 50;
        const SYSTEM_BORDER_Y = 50;
        const SYSTEM_BORDER_WIDTH = 700;
        const SYSTEM_BORDER_HEIGHT = 350;

        const CENTER_LINE_Y = SYSTEM_BORDER_Y + SYSTEM_BORDER_HEIGHT / 2;

        const ENTRY_DOOR_X = 40;
        const EXIT_DOOR_X = 750;
        const DOOR_Y_CENTER = CENTER_LINE_Y;
        const DOOR_WIDTH = 10;
        const DOOR_HEIGHT = 50;

        const CUSTOMER_RADIUS = 20; // Fixed customer radius
        const QUEUE_LINE_Y_POS = CENTER_LINE_Y + 70;
        const QUEUE_CUSTOMER_Y_POS = QUEUE_LINE_Y_POS - CUSTOMER_RADIUS - 5;
        const QUEUE_FRONT_X = 550;
        const QUEUE_SPACING_X = CUSTOMER_RADIUS * 2.5;

        const SERVER_RECT_WIDTH = 60; // Fixed width of server boxes
        const SERVER_RECT_HEIGHT = 80; // Fixed height of server boxes
        const SERVER_X_POS = SYSTEM_BORDER_X + SYSTEM_BORDER_WIDTH - SERVER_RECT_WIDTH - 80;
        const SERVER_VERTICAL_GAP = 20; // Fixed vertical gap between servers

        // Position of customer when they are 'at' a server (to the left of the server box)
        const CUSTOMER_AT_SERVER_OFFSET_X = CUSTOMER_RADIUS + 10;
        const CUSTOMER_AT_SERVER_X = SERVER_X_POS - CUSTOMER_AT_SERVER_OFFSET_X;

        // Animation Path Coordinates
        const CUSTOMER_SPAWN_X = -50; // Off-screen left (initial spawn point)
        const CUSTOMER_SPAWN_Y = DOOR_Y_CENTER;

        const CUSTOMER_POST_ENTRY_X = SYSTEM_BORDER_X + 120; // Point just past the entry door, inside the system
        const CUSTOMER_POST_ENTRY_Y = CENTER_LINE_Y;

        const CUSTOMER_PRE_EXIT_X = SERVER_X_POS + SERVER_RECT_WIDTH + CUSTOMER_RADIUS + 10; // Point just before exiting system
        const CUSTOMER_PRE_EXIT_Y = DOOR_Y_CENTER;

        const CUSTOMER_EXIT_OFFSCREEN_X = SYSTEM_BORDER_X + SYSTEM_BORDER_WIDTH + 50; // Off-screen right (final exit point)
        const CUSTOMER_EXIT_OFFSCREEN_Y = DOOR_Y_CENTER;


        // --- Simulation Logic Functions ---

        /**
         * Schedules a future event in the event queue.
         * The event queue is always kept sorted by time.
         * @param {number} time - The simulation time when this event is to occur.
         * @param {string} type - The type of event (e.g., 'ARRIVAL', 'SERVICE_COMPLETION').
         * @param {Customer} [customer=null] - The customer object related to this event.
         * @param {number} [serverId=-1] - The ID of the server involved in the event, if applicable.
         */
        function scheduleEvent(time, type, customer = null, serverId = -1) {
            eventQueue.push({ time, type, customer, serverId });
            eventQueue.sort((a, b) => a.time - b.time);
        }

        /**
         * Handles a customer arrival event.
         * Creates a new customer, initiates its entry animation, and directs it to a server or queue.
         * @param {Customer} customer - The customer object for the arriving customer.
         */
        function handleArrival(customer) {
            customer.arrivalTime = currentTime; // Mark the true arrival time in simulation

            // Visual: Create customer elements and start entry animation
            spawnCustomer(customer);

            // Logic: Decide where the customer goes AFTER entry animation
            customer.element.addEventListener('animationend', function handleEntryAnimationEnd() {
                customer.element.removeEventListener('animationend', handleEntryAnimationEnd);
                
                // Ensure customer element is at its post-entry position after animation
                customer.element.setAttribute('cx', CUSTOMER_POST_ENTRY_X);
                customer.element.setAttribute('cy', CUSTOMER_POST_ENTRY_Y);
                customer.textElement.setAttribute('x', CUSTOMER_POST_ENTRY_X);
                customer.textElement.setAttribute('y', CUSTOMER_POST_ENTRY_Y + 5);
                customer.element.style.animation = 'none'; // Clear animation styles
                customer.textElement.style.animation = 'none';
                customer.element.style.transform = 'none'; // Clear any lingering transforms
                customer.textElement.style.transform = 'none';

                let idleServerIndex = servers.findIndex(server => !server.busy);

                if (idleServerIndex !== -1) {
                    // Server is free, customer goes directly to service
                    servers[idleServerIndex].busy = true;
                    servers[idleServerIndex].customer = customer;
                    servers[idleServerIndex].busyStartTime = currentTime;
                    customer.serviceStartTime = currentTime;

                    // Apply 'in-service' styling immediately as it moves to server
                    customer.element.classList.add('customer-in-service');
                    customer.textElement.classList.add('customer-in-service');

                    const serviceTime = Distribution.generateTime(avgServiceRatePerMinPerServer, distributionType);
                    scheduleEvent(currentTime + serviceTime, 'SERVICE_COMPLETION', customer, idleServerIndex);
                    animateCustomerToService(customer, idleServerIndex);
                } else {
                    // All servers busy, customer joins the queue
                    customersInQueue.push(customer);
                    customer.queueEntryTime = currentTime;
                    animateCustomerToQueue(customer);
                }
                updateVisualization(); // Re-render customer positions
            }, { once: true }); // Listener fires only once

            // Schedule the next arrival if the simulation is set to run indefinitely or has more customers to serve
            if (noMaxCustomers || customerCounter < maxCustomersToServe) {
                const interArrivalTime = Distribution.generateTime(avgArrivalRatePerMin, distributionType);
                customerCounter++;
                scheduleEvent(currentTime + interArrivalTime, 'ARRIVAL', new Customer(customerCounter, currentTime + interArrivalTime));
            }
        }

        /**
         * Handles a service completion event.
         * A customer leaves the server, exits the system, and the next customer in queue (if any) is moved to the server.
         * @param {Customer} customer - The customer whose service is completing.
         * @param {number} serverId - The index of the server that just finished service.
         */
        function handleServiceCompletion(customer, serverId) {
            // Free up the server
            servers[serverId].busy = false;
            servers[serverId].customer = null;
            servers[serverId].busyStartTime = null;

            customer.serviceEndTime = currentTime;
            customer.leaveTime = currentTime;
            completedCustomers.push(customer); // Add to completed list for metrics

            // Remove 'in-service' styling before animating out
            if (customer.element) { // Check if element exists before removing class
                customer.element.classList.remove('customer-in-service');
                customer.textElement.classList.remove('customer-in-service');
            }
            animateCustomerLeaving(customer); // Start visual exit animation

            // If there are customers in the queue, move the next one to this freed server
            if (customersInQueue.length > 0) {
                const nextCustomer = customersInQueue.shift(); // Remove from front of queue
                
                servers[serverId].busy = true;
                servers[serverId].customer = nextCustomer;
                servers[serverId].busyStartTime = currentTime;
                nextCustomer.serviceStartTime = currentTime;

                // Apply 'in-service' styling to the next customer as they move to server
                if (nextCustomer.element) { // Check if element exists
                    nextCustomer.element.classList.add('customer-in-service');
                    nextCustomer.textElement.classList.add('customer-in-service');
                }

                const serviceTime = Distribution.generateTime(avgServiceRatePerMinPerServer, distributionType);
                scheduleEvent(currentTime + serviceTime, 'SERVICE_COMPLETION', nextCustomer, serverId);
                animateCustomerToService(nextCustomer, serverId);
            }
            updateVisualization(); // Re-render customer positions
        }

        // --- Visualization Helper Functions ---

        /**
         * Draws the static server rectangles and their labels on the SVG canvas.
         * This function is called during initialization or when numServers changes.
         * @param {number} index - The 0-based index of the server to draw.
         */
        function drawServer(index) {
            // Calculate vertical position to center servers if multiple
            const totalServersHeight = numServers * SERVER_RECT_HEIGHT + (numServers - 1) * SERVER_VERTICAL_GAP;
            const serverGroupTopY = CENTER_LINE_Y - (totalServersHeight / 2);
            const serverY = serverGroupTopY + (index * (SERVER_RECT_HEIGHT + SERVER_VERTICAL_GAP));

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', SERVER_X_POS);
            rect.setAttribute('y', serverY);
            rect.setAttribute('width', SERVER_RECT_WIDTH);
            rect.setAttribute('height', SERVER_RECT_HEIGHT);
            rect.setAttribute('rx', 10);
            rect.setAttribute('ry', 10);
            rect.classList.add('server-item');
            serversGroup.appendChild(rect);

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('x', SERVER_X_POS + SERVER_RECT_WIDTH / 2);
            text.setAttribute('y', serverY + SERVER_RECT_HEIGHT / 2 + 5); /* Adjust for text baseline */
            text.textContent = `S${index + 1}`;
            text.classList.add('server-text');
            serversGroup.appendChild(text);
        }

        /**
         * Updates the visual positions and states of all customers on the SVG canvas.
         * This function is called frequently by runNextEvent.
         */
        function updateVisualization() {
            // Get IDs of customers currently in queue or being served
            const logicallyPresentCustomerIds = new Set();
            customersInQueue.forEach(c => logicallyPresentCustomerIds.add(c.id));
            servers.forEach(s => {
                if (s.busy && s.customer) {
                    logicallyPresentCustomerIds.add(s.customer.id);
                }
            });

            // Iterate through all customer objects that *might* have elements
            for (let customer of allCustomerObjects.values()) {
                // If a customer object exists, but its SVG elements do not, and it's logically present or still being visualized, create them.
                if ((!customer.element || !customer.textElement) && (logicallyPresentCustomerIds.has(customer.id) || customer.isVisualized)) {
                    // Create elements at their logical current position, or spawn point if just arrived
                    let initialX = CUSTOMER_SPAWN_X;
                    let initialY = CUSTOMER_SPAWN_Y;

                    // If customer is already in queue or service, create it directly at that spot
                    if (logicallyPresentCustomerIds.has(customer.id)) {
                        let isServing = servers.some(s => s.customer && s.customer.id === customer.id);
                        if (isServing) {
                            const serverIdx = servers.findIndex(s => s.customer && s.customer.id === customer.id);
                            initialY = calculateServerYCenter(serverIdx);
                            initialX = CUSTOMER_AT_SERVER_X;
                        } else { // In queue
                            const queueIdx = customersInQueue.findIndex(c => c.id === customer.id);
                            initialX = QUEUE_FRONT_X - (queueIdx * QUEUE_SPACING_X);
                            initialY = QUEUE_CUSTOMER_Y_POS;
                        }
                    }
                    createCustomerElements(customer, initialX, initialY);
                }

                // Now, if elements exist, update their positions or remove them if no longer needed
                if (customer.element && customer.textElement) {
                    // Check if customer should be removed (fully left system and isVisualized is false)
                    if (!customer.isVisualized) {
                        // This means the customer's exit animation has completed, and it should be removed.
                        customer.element.remove();
                        customer.textElement.remove();
                        allCustomerObjects.delete(customer.id); // Remove from map
                        continue; // Move to next customer
                    }

                    // If customer is still visualized, update its position and styling
                    let targetX, targetY;
                    let isServing = servers.some(s => s.customer && s.customer.id === customer.id);

                    if (isServing) {
                        const serverIdx = servers.findIndex(s => s.customer && s.customer.id === customer.id);
                        targetY = calculateServerYCenter(serverIdx);
                        targetX = CUSTOMER_AT_SERVER_X;
                        customer.element.classList.add('customer-in-service'); // Ensure red color
                        customer.textElement.classList.add('customer-in-service');
                    } else { // In queue
                        const queueIdx = customersInQueue.findIndex(c => c.id === customer.id);
                        targetX = QUEUE_FRONT_X - (queueIdx * QUEUE_SPACING_X);
                        targetY = QUEUE_CUSTOMER_Y_POS;
                        customer.element.classList.remove('customer-in-service'); // Ensure not red
                        customer.textElement.classList.remove('customer-in-service');
                    }

                    const currentCx = parseFloat(customer.element.getAttribute('cx'));
                    const currentCy = parseFloat(customer.element.getAttribute('cy'));

                    // Only apply transition if no animation is running and positions differ
                    // Animations (like `moveToService`, `enterPath`, `leavePath`) handle their own `cx`/`cy` updates on `animationend`.
                    // This `updateVisualization` part handles static positioning or subtle queue shifts via `transition`.
                    if (!customer.element.style.animationName || customer.element.style.animationName === 'none') {
                        if (currentCx !== targetX || currentCy !== targetY) {
                            customer.element.style.transition = 'transform 0.3s ease-out';
                            customer.textElement.style.transition = 'transform 0.3s ease-out';
                            
                            const translateX = targetX - currentCx;
                            const translateY = targetY - currentCy;

                            customer.element.style.transform = `translate(${translateX}px, ${translateY}px)`;
                            customer.textElement.style.transform = `translate(${translateX}px, ${translateY}px)`;

                            customer.element.addEventListener('transitionend', function handler() {
                                customer.element.removeEventListener('transitionend', handler);
                                customer.element.style.transition = 'none';
                                customer.textElement.style.transition = 'none';
                                customer.element.style.transform = 'translate(0,0)'; // Clear transform
                                customer.textElement.style.transform = 'none'; // Clear transform for text as well
                                customer.element.setAttribute('cx', targetX); // Set final position as attributes
                                customer.element.setAttribute('cy', targetY);
                                customer.textElement.setAttribute('x', targetX);
                                customer.textElement.setAttribute('y', targetY + 5); 
                            }, { once: true });
                        } else {
                            // If at correct position and no animation, ensure attributes are set
                            customer.element.setAttribute('cx', targetX);
                            customer.element.setAttribute('cy', targetY);
                            customer.textElement.setAttribute('x', targetX);
                            customer.textElement.setAttribute('y', targetY + 5); 
                        }
                    }
                }
            }
        }

        /**
         * Calculates the vertical center position for a server's visual representation.
         * This helps in evenly spacing multiple servers.
         * @param {number} index - The 0-based index of the server.
         * @returns {number} The Y-coordinate for the center of the server.
         */
        function calculateServerYCenter(index) {
            const totalServersHeight = numServers * SERVER_RECT_HEIGHT + (numServers - 1) * SERVER_VERTICAL_GAP;
            const serverGroupTopY = CENTER_LINE_Y - (totalServersHeight / 2);
            return serverGroupTopY + (index * (SERVER_RECT_HEIGHT + SERVER_VERTICAL_GAP)) + SERVER_RECT_HEIGHT / 2;
        }

        /**
         * Creates and appends SVG circle (for visual body) and text (for ID) elements for a customer.
         * Links these SVG elements back to the Customer object for easy manipulation.
         * Sets `customer.isVisualized` to true.
         * @param {Customer} customer - The Customer object to associate elements with.
         * @param {number} x - Initial X coordinate for the customer circle.
         * @param {number} y - Initial Y coordinate for the customer circle.
         * @param {string} [extraClass=''] - Optional extra CSS class for styling.
         */
        function createCustomerElements(customer, x, y, extraClass = '') {
            if (customer.element) return; // Prevent recreation if already exists

            const circle = document.createElementNS(SVG_NS, 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', CUSTOMER_RADIUS); // Use fixed radius
            circle.classList.add('customer-circle');
            if (extraClass) circle.classList.add(extraClass);
            circle.setAttribute('id', `customer-circle-${customer.id}`);
            simulationCanvas.appendChild(circle);
            customer.element = circle;

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y + 5); 
            text.setAttribute('text-anchor', 'middle'); /* Center text horizontally */
            text.textContent = customer.id;
            text.classList.add('customer-text');
            if (extraClass) text.classList.add(extraClass);
            text.setAttribute('id', `customer-text-${customer.id}`);
            simulationCanvas.appendChild(text);
            customer.textElement = text;

            customer.isVisualized = true; // Mark as visualized
        }

        /**
         * Applies a CSS keyframe animation to a customer's SVG elements.
         * Resets previous animation states and sets CSS variables for dynamic movement.
         * @param {SVGElement} element - The customer's circle SVG element.
         * @param {SVGElement} textElement - The customer's text SVG element.
         * @param {number} initialX - The starting X position for the animation.
         * @param {number} initialY - The starting Y position for the animation.
         * @param {number} targetX - The ending X position for the animation.
         * @param {number} targetY - The ending Y position for the animation.
         * @param {string} animationClass - The name of the CSS keyframe animation (e.g., 'enterPath', 'moveToService').
         * @param {number} [duration=0.5] - Duration of the animation in seconds.
         */
        function animateElement(element, textElement, initialX, initialY, targetX, targetY, animationClass, duration = 0.5) {
            // Clear previous animations and classes to ensure new animation starts correctly
            element.style.animation = 'none';
            textElement.style.animation = 'none';
            element.classList.remove('customer-entering-path', 'customer-moving-to-server', 'customer-leaving-path');
            textElement.classList.remove('customer-entering-path', 'customer-moving-to-server', 'customer-leaving-path');

            // Force reflow: This ensures the browser applies the `animation: none` and class removals
            // before applying the new animation. Without this, the browser might optimize out the
            // intermediate states, causing animation glitches.
            void element.offsetWidth;
            void textElement.offsetWidth;

            // Set the *actual* attributes to the initial position. CSS `transform` will then animate FROM this.
            element.setAttribute('cx', initialX);
            element.setAttribute('cy', initialY);
            textElement.setAttribute('x', initialX);
            textElement.setAttribute('y', initialY + 5); 

            // Set CSS variables for keyframe calculations (used in @keyframes rules)
            element.style.setProperty('--initial-x', `${initialX}`);
            element.style.setProperty('--initial-y', `${initialY}`);
            element.style.setProperty('--target-x', `${targetX}`);
            element.style.setProperty('--target-y', `${targetY}`);

            // Apply the new animation
            element.style.animation = `${animationClass} ${duration}s ease-in-out forwards`;
            textElement.style.animation = `${animationClass} ${duration}s ease-in-out forwards`;
        }

        /**
         * Initiates the visual "spawn" and entry animation for a new customer.
         * @param {Customer} customer - The customer to animate.
         */
        function spawnCustomer(customer) {
            createCustomerElements(customer, CUSTOMER_SPAWN_X, CUSTOMER_SPAWN_Y);
            animateElement(
                customer.element, customer.textElement,
                CUSTOMER_SPAWN_X, CUSTOMER_SPAWN_Y,
                CUSTOMER_POST_ENTRY_X, CUSTOMER_POST_ENTRY_Y,
                'enterPath', 1.0 // Longer duration for entry
            );
        }

        /**
         * Animates a customer from their current position to their spot in the queue.
         * Also shifts other customers in the queue if necessary.
         * @param {Customer} customer - The customer moving to the queue.
         */
        function animateCustomerToQueue(customer) {
            // Calculate target position in queue (based on its current index)
            const targetX = QUEUE_FRONT_X - (customersInQueue.indexOf(customer) * QUEUE_SPACING_X);
            const targetY = QUEUE_CUSTOMER_Y_POS;

            const currentX = parseFloat(customer.element.getAttribute('cx'));
            const currentY = parseFloat(customer.element.getAttribute('cy'));

            animateElement(
                customer.element, customer.textElement,
                currentX, currentY,
                targetX, targetY,
                'moveToService', 0.5
            );

            customer.element.addEventListener('animationend', function handler() {
                customer.element.removeEventListener('animationend', handler);
                // After animation, apply final positions and clear transform
                customer.element.style.animation = 'none';
                customer.textElement.style.animation = 'none';
                customer.element.setAttribute('cx', targetX);
                customer.element.setAttribute('cy', targetY);
                customer.textElement.setAttribute('x', targetX);
                customer.textElement.setAttribute('y', targetY + 5); 
                customer.element.style.transform = 'none';
                customer.textElement.style.transform = 'none';
            }, { once: true });
        }

        /**
         * Animates a customer from their current position (queue or entry point) to a server.
         * @param {Customer} customer - The customer moving to the server.
         * @param {number} serverId - The index of the server the customer is moving to.
         */
        function animateCustomerToService(customer, serverId) {
            const serverY = calculateServerYCenter(serverId);

            const currentX = parseFloat(customer.element.getAttribute('cx'));
            const currentY = parseFloat(customer.element.getAttribute('cy'));

            animateElement(
                customer.element, customer.textElement,
                currentX, currentY,
                CUSTOMER_AT_SERVER_X, serverY, // Use fixed X for server position
                'moveToService', 0.5
            );

            // The 'customer-in-service' class is now applied at the start of service (in handleArrival or handleServiceCompletion)
            // The animationend listener just confirms position and clears transform
            customer.element.addEventListener('animationend', function handler() {
                customer.element.removeEventListener('animationend', handler);
                customer.element.style.animation = 'none';
                customer.textElement.style.animation = 'none';
                customer.element.setAttribute('cx', CUSTOMER_AT_SERVER_X);
                customer.element.setAttribute('cy', serverY);
                customer.textElement.setAttribute('x', CUSTOMER_AT_SERVER_X);
                customer.textElement.setAttribute('y', serverY + 5); 
                customer.element.style.transform = 'none';
                customer.textElement.style.transform = 'none';
            }, { once: true });
        }

        /**
         * Animates a customer leaving the system after service is complete.
         * Moves them from the server, past the exit door, and off-screen.
         * @param {Customer} customer - The customer leaving.
         */
        function animateCustomerLeaving(customer) {
            if (customer.element && customer.textElement) {
                const currentX = parseFloat(customer.element.getAttribute('cx'));
                const currentY = parseFloat(customer.element.getAttribute('cy'));

                // First animation: From server to just before exit door
                animateElement(
                    customer.element, customer.textElement,
                    currentX, currentY,
                    CUSTOMER_PRE_EXIT_X, CUSTOMER_PRE_EXIT_Y, // Use fixed X for pre-exit
                    'moveToService', 0.5
                );

                customer.element.addEventListener('animationend', function handleExitDoorAnimationEnd() {
                    customer.element.removeEventListener('animationend', handleExitDoorAnimationEnd);
                    customer.element.style.animation = 'none';
                    customer.textElement.style.animation = 'none';
                    customer.element.setAttribute('cx', CUSTOMER_PRE_EXIT_X);
                    customer.element.setAttribute('cy', CUSTOMER_PRE_EXIT_Y);
                    customer.textElement.setAttribute('x', CUSTOMER_PRE_EXIT_X);
                    customer.textElement.setAttribute('y', CUSTOMER_PRE_EXIT_Y + 5); 
                    customer.element.style.transform = 'none';
                    customer.textElement.style.transform = 'none';

                    // Second animation: From exit door to off-screen
                    animateElement(
                        customer.element, customer.textElement,
                        CUSTOMER_PRE_EXIT_X, CUSTOMER_PRE_EXIT_Y,
                        CUSTOMER_EXIT_OFFSCREEN_X, CUSTOMER_EXIT_OFFSCREEN_Y, // Use fixed X for off-screen exit
                        'leavePath', 1.0 // Longer duration for exit
                    );

                    customer.element.addEventListener('animationend', function handleFinalExitAnimationEnd() {
                        customer.element.removeEventListener('animationend', handleFinalExitAnimationEnd);
                        // Finally, remove the elements from the DOM after they are off-screen
                        customer.element.remove();
                        customer.textElement.remove();
                        customer.isVisualized = false; // Mark as no longer visualized
                        allCustomerObjects.delete(customer.id); // Remove from global map
                    }, { once: true });
                }, { once: true });
            }
        }


        // --- Metric Update Function ---

        /**
         * Updates all real-time metrics displayed on the UI.
         * Calculates averages and utilization based on accumulated data.
         */
        function updateMetrics() {
            // Display current state metrics
            currentTimeDisplay.textContent = currentTime.toFixed(2);
            const busyServersCount = servers.filter(s => s.busy).length;
            customersInSystemDisplay.textContent = customersInQueue.length + busyServersCount;
            customersInQueueDisplay.textContent = customersInQueue.length;
            customersInServiceDisplay.textContent = busyServersCount;
            customersServedDisplay.textContent = completedCustomers.length;

            // Calculate and display average times
            let totalWait = 0;
            let totalTimeInSystem = 0;
            completedCustomers.forEach(c => {
                // Ensure values are not null before calculating
                if (c.serviceStartTime !== null && c.queueEntryTime !== null) {
                    totalWait += (c.serviceStartTime - c.queueEntryTime);
                }
                if (c.leaveTime !== null && c.arrivalTime !== null) {
                    totalTimeInSystem += (c.leaveTime - c.arrivalTime);
                }
            });

            const avgWait = completedCustomers.length > 0 ? (totalWait / completedCustomers.length) : 0;
            avgWaitTimeDisplay.textContent = avgWait.toFixed(2);

            const avgSysTime = completedCustomers.length > 0 ? (totalTimeInSystem / completedCustomers.length) : 0;
            avgTimeInSystemDisplay.textContent = avgSysTime.toFixed(2);

            // Calculate and display average customers (Lq and L)
            const avgCustomersInQueue = currentTime > 0 ? (totalCustomersInQueueArea / currentTime) : 0;
            avgCustomersInQueueDisplay.textContent = avgCustomersInQueue.toFixed(2);

            const avgCustomersInSystem = currentTime > 0 ? (totalCustomersInSystemArea / currentTime) : 0;
            avgCustomersInSystemDisplay.textContent = avgCustomersInSystem.toFixed(2);

            // Calculate and display system utilization
            const theoreticalMaxBusyTime = currentTime * numServers;
            const actualUtilization = theoreticalMaxBusyTime > 0 ? (totalSystemBusyTime / theoreticalMaxBusyTime) : 0;
            systemUtilizationDisplay.textContent = (Math.min(actualUtilization, 1) * 100).toFixed(2) + '%';
        }

        // --- Simulation Control Functions ---

        /**
         * Initializes the 'servers' array and draws their visual representations on the SVG.
         * Called on reset and initial load.
         */
        function initializeServers() {
            servers = [];
            serversGroup.innerHTML = ''; // Clear any existing server visuals

            // Calculate total height needed for servers to center them vertically
            const totalServersHeight = numServers * SERVER_RECT_HEIGHT + (numServers - 1) * SERVER_VERTICAL_GAP;
            const serverGroupTopY = CENTER_LINE_Y - (totalServersHeight / 2);

            for (let i = 0; i < numServers; i++) {
                servers.push({ busy: false, customer: null, busyStartTime: null });
                drawServer(i);
            }
        }

        /**
         * Starts or resumes the simulation. Validates input parameters and schedules the first event.
         */
        function startSimulation() {
            // Read current values from input fields
            avgArrivalRatePerMin = parseFloat(arrivalRateInput.value);
            avgServiceRatePerMinPerServer = parseFloat(serviceRateInput.value);
            numServers = parseInt(numServersInput.value);
            simSpeedMsPerSec = parseInt(simSpeedInput.value);
            maxCustomersToServe = parseInt(maxCustomersInput.value);
            noMaxCustomers = noMaxCustomersCheckbox.checked;

            // Input validation
            if (isNaN(avgArrivalRatePerMin) || avgArrivalRatePerMin <= 0 ||
                isNaN(avgServiceRatePerMinPerServer) || avgServiceRatePerMinPerServer <= 0 ||
                isNaN(numServers) || numServers < 1 ||
                isNaN(simSpeedMsPerSec) || simSpeedMsPerSec < 10 ||
                (!noMaxCustomers && (isNaN(maxCustomersToServe) || maxCustomersToServe < 1))) {
                statusMessageDisplay.textContent = "Please enter valid positive numbers for all parameters.";
                statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800', 'bg-orange-100', 'text-orange-800', 'bg-green-100', 'text-green-800');
                statusMessageDisplay.classList.add('bg-red-100', 'text-red-800');
                return;
            }

            // M/M/S stability condition (λ < S * μ) warning
            if (distributionType === 'exponential' && avgArrivalRatePerMin >= (numServers * avgServiceRatePerMinPerServer)) {
                statusMessageDisplay.textContent = "Warning: Arrival rate is >= total service rate. Queue will likely grow indefinitely (unstable M/M/S system).";
                statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800', 'bg-green-100', 'text-green-800');
                statusMessageDisplay.classList.add('bg-orange-100', 'text-orange-800');
            } else {
                statusMessageDisplay.classList.remove('bg-red-100', 'text-red-800', 'bg-orange-100', 'text-orange-800');
                statusMessageDisplay.textContent = "Simulation running...";
                statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
            }

            // Disable Start, enable Stop, disable Reset while running
            startButton.disabled = true;
            stopButton.disabled = false;
            resetButton.disabled = true;

            // Clear any existing interval if START is pressed again while simulation is already active
            if (simulationInterval) {
                clearInterval(simulationInterval);
            }

            // If event queue is empty (first run or after full reset), schedule the very first arrival
            if (eventQueue.length === 0 && completedCustomers.length === 0) {
                customerCounter = 1; // Start customer IDs from 1
                scheduleEvent(0, 'ARRIVAL', new Customer(customerCounter, 0)); // First arrival at time 0
            }
            
            // Set the interval for the simulation's discrete event steps
            const intervalDuration = simSpeedMsPerSec * 60; // Convert ms/sim-second to ms/sim-minute
            simulationInterval = setInterval(runNextEvent, intervalDuration);
        }

        /**
         * Stops the simulation, clearing the interval.
         */
        function stopSimulation() {
            clearInterval(simulationInterval);
            simulationInterval = null; // Clear the interval ID
            startButton.disabled = false;
            stopButton.disabled = true;
            resetButton.disabled = false; // Enable reset after stopping
            statusMessageDisplay.textContent = "Simulation paused.";
            statusMessageDisplay.classList.remove('bg-orange-100', 'text-orange-800', 'bg-green-100', 'text-green-800');
            statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
        }

        /**
         * Resets the entire simulation state and UI to initial values.
         */
        function resetSimulation() {
            stopSimulation(); // First, ensure the simulation is stopped

            // Reset all simulation state variables
            currentTime = 0;
            customerCounter = 0;
            eventQueue = [];
            customersInQueue = [];
            servers = [];
            completedCustomers = [];
            totalSystemBusyTime = 0;
            totalCustomersInQueueArea = 0;
            totalCustomersInSystemArea = 0;
            lastMetricUpdateTime = 0; // Reset last update time for metrics

            // Remove all dynamic customer elements from the SVG canvas
            const allCustomerElementsOnCanvas = simulationCanvas.querySelectorAll('.customer-circle, .customer-text');
            allCustomerElementsOnCanvas.forEach(el => el.remove());
            allCustomerObjects.clear(); // Clear the global map of customer objects

            // Re-initialize servers based on current numServers input value
            initializeServers();

            // Update UI to reflect reset state (all zeros)
            updateMetrics();
            updateVisualization(); // Ensure visualization is cleared and reset

            // Reset status message and button states
            statusMessageDisplay.textContent = "Adjust parameters and click START.";
            statusMessageDisplay.classList.remove('bg-red-100', 'text-red-800', 'bg-orange-100', 'text-orange-800', 'bg-green-100', 'text-green-800');
            statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
            startButton.disabled = false;
            resetButton.disabled = false;
        }

        /**
         * Main simulation loop function.
         * Processes the next event in the queue and updates the simulation state and UI.
         */
        function runNextEvent() {
            if (eventQueue.length === 0) {
                // If there are no more events, stop the simulation
                if (noMaxCustomers) {
                    statusMessageDisplay.textContent = "No more events scheduled. Simulation might be idle or inputs led to no further activity.";
                } else if (completedCustomers.length >= maxCustomersToServe) {
                    statusMessageDisplay.textContent = `Simulation finished: ${completedCustomers.length} customers served.`;
                    statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800', 'bg-orange-100', 'text-orange-800');
                    statusMessageDisplay.classList.add('bg-green-100', 'text-green-800');
                } else {
                    statusMessageDisplay.textContent = "No more events. Simulation might be stuck.";
                    statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800');
                    statusMessageDisplay.classList.add('bg-red-100', 'text-red-800');
                }
                stopSimulation();
                return; // Exit the function
            }

            const nextEventTime = eventQueue[0].time;
            const timePassed = nextEventTime - currentTime; // This is the duration since the last event processed

            // Accumulate metrics for the interval just passed (from currentTime to nextEventTime)
            // The system state (queue length, busy servers) remained constant during this 'timePassed' interval.
            if (timePassed > 0) {
                totalCustomersInQueueArea += customersInQueue.length * timePassed;
                totalCustomersInSystemArea += (customersInQueue.length + servers.filter(s => s.busy).length) * timePassed;
                
                servers.forEach(server => {
                    if (server.busy) {
                        totalSystemBusyTime += timePassed;
                    }
                });
            }

            // Process the next event
            const nextEvent = eventQueue.shift();
            currentTime = nextEvent.time; // Advance simulation time

            // Process the event based on its type
            switch (nextEvent.type) {
                case 'ARRIVAL':
                    handleArrival(nextEvent.customer);
                    break;
                case 'SERVICE_COMPLETION':
                    handleServiceCompletion(nextEvent.customer, nextEvent.serverId);
                    break;
            }
            
            // Now call updateMetrics to display the calculated values based on the accumulated totals
            // and the current simulation time.
            updateMetrics();
            updateVisualization();
        }

        // --- Event Listeners and Initial Setup ---

        /**
         * Initializes all DOM element references and attaches event listeners.
         * This function is called once the entire HTML document has been loaded and parsed.
         */
        window.onload = function() {
            // Assign DOM elements to the globally declared variables
            arrivalRateInput = document.getElementById('arrivalRate');
            serviceRateInput = document.getElementById('serviceRate');
            numServersInput = document.getElementById('numServers');
            simSpeedInput = document.getElementById('simSpeed');
            maxCustomersInput = document.getElementById('maxCustomers');
            noMaxCustomersCheckbox = document.getElementById('noMaxCustomers');
            maxCustomersContainer = document.getElementById('maxCustomersContainer');
            distExpRadio = document.getElementById('distExp');
            distFixedRadio = document.getElementById('distFixed');

            startButton = document.getElementById('startButton');
            stopButton = document.getElementById('stopButton');
            resetButton = document.getElementById('resetButton');

            currentTimeDisplay = document.getElementById('currentTime');
            customersInSystemDisplay = document.getElementById('customersInSystem');
            customersInQueueDisplay = document.getElementById('customersInQueue');
            customersInServiceDisplay = document.getElementById('customersInService');
            avgWaitTimeDisplay = document.getElementById('avgWaitTime');
            avgTimeInSystemDisplay = document.getElementById('avgTimeInSystem');
            avgCustomersInQueueDisplay = document.getElementById('avgCustomersInQueueDisplay');
            avgCustomersInSystemDisplay = document.getElementById('avgCustomersInSystemDisplay');
            systemUtilizationDisplay = document.getElementById('systemUtilization');
            customersServedDisplay = document.getElementById('customersServed');
            statusMessageDisplay = document.getElementById('statusMessage');

            simulationCanvas = document.getElementById('simulationCanvas');
            serversGroup = document.getElementById('serversGroup');

            // Attach event listeners to buttons
            startButton.addEventListener('click', startSimulation);
            stopButton.addEventListener('click', stopSimulation);
            resetButton.addEventListener('click', resetSimulation);

            // Add change listeners for input fields to update status/visualization when not running
            [arrivalRateInput, serviceRateInput, numServersInput].forEach(input => {
                input.addEventListener('change', () => {
                    // Only react to changes if simulation is not currently running
                    if (!simulationInterval) {
                        const currentArrivalRate = parseFloat(arrivalRateInput.value);
                        const currentServiceRate = parseFloat(serviceRateInput.value);
                        const currentNumServers = parseInt(numServersInput.value);

                        // Re-evaluate and display stability warning if needed
                        if (distributionType === 'exponential' && currentArrivalRate >= (currentNumServers * currentServiceRate)) {
                            statusMessageDisplay.textContent = "Warning: Arrival rate is >= total service rate. Queue will likely grow indefinitely (unstable M/M/S system).";
                            statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800', 'bg-green-100', 'text-green-800');
                            statusMessageDisplay.classList.add('bg-orange-100', 'text-orange-800');
                        } else {
                            statusMessageDisplay.classList.remove('bg-red-100', 'text-red-800', 'bg-orange-100', 'text-orange-800');
                            statusMessageDisplay.textContent = "Adjust parameters and click START.";
                            statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
                        }
                        // Re-initialize servers and update visualization if numServers changed and sim is not running
                        initializeServers();
                        updateVisualization();
                    }
                });
            });

            // Handle the 'No Maximum Customers' checkbox
            noMaxCustomersCheckbox.addEventListener('change', () => {
                noMaxCustomers = noMaxCustomersCheckbox.checked;
                if (noMaxCustomers) {
                    maxCustomersContainer.style.display = 'none';
                } else {
                    maxCustomersContainer.style.display = 'block';
                }
            });

            // Handle changes in distribution type radio buttons
            distExpRadio.addEventListener('change', (e) => {
                distributionType = e.target.value;
                const currentArrivalRate = parseFloat(arrivalRateInput.value);
                const currentServiceRate = parseFloat(serviceRateInput.value);
                const currentNumServers = parseInt(numServersInput.value);

                // Update stability warning if exponential is selected
                if (distributionType === 'exponential' && currentArrivalRate >= (currentNumServers * currentServiceRate)) {
                    statusMessageDisplay.textContent = "Warning: Arrival rate is >= total service rate. Queue will likely grow indefinitely (unstable M/M/S system).";
                    statusMessageDisplay.classList.remove('bg-blue-100', 'text-blue-800', 'bg-green-100', 'text-green-800');
                    statusMessageDisplay.classList.add('bg-orange-100', 'text-orange-800');
                } else {
                    statusMessageDisplay.classList.remove('bg-red-100', 'text-red-800', 'bg-orange-100', 'text-orange-800');
                    statusMessageDisplay.textContent = "Adjust parameters and click START.";
                    statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
                }
            });
            distFixedRadio.addEventListener('change', (e) => {
                distributionType = e.target.value;
                statusMessageDisplay.textContent = "Fixed distribution selected. Note: This deviates from a pure M/M/S model.";
                statusMessageDisplay.classList.remove('bg-red-100', 'text-red-800', 'bg-orange-100', 'text-orange-800', 'bg-green-100', 'text-green-800');
                statusMessageDisplay.classList.add('bg-blue-100', 'text-blue-800');
            });

            // Initial setup for max customers input visibility based on default checkbox state
            noMaxCustomers = noMaxCustomersCheckbox.checked;
            if (noMaxCustomers) {
                maxCustomersContainer.style.display = 'none';
            } else {
                maxCustomersContainer.style.display = 'block';
            }

            // Perform a full reset to set the initial UI state and parameters when the page loads
            resetSimulation();
        };
    </script>
</body>
</html>
